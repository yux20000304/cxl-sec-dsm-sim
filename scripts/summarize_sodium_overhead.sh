#!/usr/bin/env bash
set -euo pipefail

# Summarize overhead for the libsodium tunnel + redis-benchmark client.
# Produces per-op time (us/op) for:
# - crypto (tunnel encrypt/decrypt): client+server
# - copy (tunnel read/write syscalls): client+server
# - client syscalls (redis-benchmark): net_read / net_write / net_wait / other_sys / total_sys
# and writes a short CSV.
#
# Inputs: results generated by host_recreate_and_bench_tdx.sh sodium stage:
#   results/sodium_server_stats_<TS>.json
#   results/sodium_client_stats_<TS>.json
#   results/sodium_rb_<TS>.strace.sum
#
# Usage:
#   bash scripts/summarize_sodium_overhead.sh --ts 20260131_232552 \
#     --ops-per-test 200000 --tests-count 2
#   # If --ts is omitted, the latest results/*sodium_server_stats_*.json is used.

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUTDIR="${ROOT}/results"

TS=""
OPS_PER_TEST=200000
TESTS_COUNT=2
CSV_OUT=""

usage() {
  echo "Usage: $0 [--ts TS] [--ops-per-test N] [--tests-count K] [--csv path]" >&2
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --ts) TS="$2"; shift 2 ;;
    --ops-per-test) OPS_PER_TEST="$2"; shift 2 ;;
    --tests-count) TESTS_COUNT="$2"; shift 2 ;;
    --csv) CSV_OUT="$2"; shift 2 ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1" >&2; usage; exit 1 ;;
  esac
done

if [[ -z "${TS}" ]]; then
  # Pick latest sodium_server_stats_*.json and extract TS suffix
  latest=$(ls -1t "${OUTDIR}"/sodium_server_stats_*.json 2>/dev/null | head -n1 || true)
  if [[ -z "${latest}" ]]; then
    echo "[!] No sodium_server_stats_*.json found under ${OUTDIR}" >&2
    exit 1
  fi
  base=$(basename "${latest}")
  TS="${base#sodium_server_stats_}"
  TS="${TS%.json}"
fi

srv_json="${OUTDIR}/sodium_server_stats_${TS}.json"
cli_json="${OUTDIR}/sodium_client_stats_${TS}.json"
strace_sum="${OUTDIR}/sodium_rb_${TS}.strace.sum"

for f in "${srv_json}" "${cli_json}" "${strace_sum}"; do
  if [[ ! -f "${f}" ]]; then
    echo "[!] Missing artifact: ${f}" >&2
    exit 1
  fi
done

extract_json_field() {
  local file="$1" key="$2"
  # naive parser: assumes key": <number>
  sed -n "s/.*\"${key}\"[: ]*\([0-9][0-9]*\).*/\1/p" "${file}" | head -n1
}

sum_fields() {
  local file="$1"; shift
  local total=0 v
  for k in "$@"; do
    v=$(extract_json_field "${file}" "${k}")
    : "${v:=0}"
    total=$(( total + v ))
  done
  echo "${total}"
}

# Sodium tunnel: crypto and copy (ns)
srv_crypto_ns=$(sum_fields "${srv_json}" crypto_push_ns crypto_pull_ns)
cli_crypto_ns=$(sum_fields "${cli_json}" crypto_push_ns crypto_pull_ns)
srv_copy_ns=$(sum_fields "${srv_json}" read_ns write_ns)
cli_copy_ns=$(sum_fields "${cli_json}" read_ns write_ns)

crypto_ns_total=$(( srv_crypto_ns + cli_crypto_ns ))
copy_ns_total=$(( srv_copy_ns + cli_copy_ns ))

# redis-benchmark strace summary: group syscall seconds
read -r rb_net_read rb_net_write rb_net_wait rb_other rb_total_sys < <(
  awk '
    /^% time/ {hdr=1; next}
    /^[ -]/ {next}
    NF<6 {next}
    {sec=$2; sc=$6; t[sc]+=sec; tot+=sec}
    END{
      nread = t["read"]+t["readv"]+t["recv"]+t["recvfrom"]+t["recvmsg"];
      nwrite = t["write"]+t["writev"]+t["send"]+t["sendto"]+t["sendmsg"];
      nwait = t["poll"]+t["ppoll"]+t["select"]+t["pselect6"]+t["epoll_wait"]+t["epoll_pwait"];
      other = tot-(nread+nwrite+nwait);
      if (nread<0) nread=0; if (nwrite<0) nwrite=0; if (nwait<0) nwait=0; if (other<0) other=0;
      printf "%.6f %.6f %.6f %.6f %.6f\n", nread, nwrite, nwait, other, tot;
    }
  ' "${strace_sum}"
)

ops_total=$(( OPS_PER_TEST * TESTS_COUNT ))
if [[ "${ops_total}" -le 0 ]]; then ops_total=1; fi

ns_to_us_per_op() { awk -v x="$1" -v n="$2" 'BEGIN{printf "%.2f", (x/1000.0)/n}' ; }
sec_to_us_per_op() { awk -v s="$1" -v n="$2" 'BEGIN{printf "%.2f", (s*1e6)/n}' ; }

enc_us=$(ns_to_us_per_op "${crypto_ns_total}" "${ops_total}")
copy_us=$(ns_to_us_per_op "${copy_ns_total}" "${ops_total}")
rb_read_us=$(sec_to_us_per_op "${rb_net_read}" "${ops_total}")
rb_write_us=$(sec_to_us_per_op "${rb_net_write}" "${ops_total}")
rb_wait_us=$(sec_to_us_per_op "${rb_net_wait}" "${ops_total}")
rb_other_us=$(sec_to_us_per_op "${rb_other}" "${ops_total}")
rb_sys_total_us=$(sec_to_us_per_op "${rb_total_sys}" "${ops_total}")

echo "[sodium overhead summary] TS=${TS} ops_total=${ops_total}"
echo "- encrypt/decrypt (client+server):   ${enc_us} us/op"
echo "- read/write copy (client+server):   ${copy_us} us/op"
echo "- redis-benchmark syscalls per op:   read=${rb_read_us} write=${rb_write_us} wait=${rb_wait_us} other=${rb_other_us} total_sys=${rb_sys_total_us}"

if [[ -n "${CSV_OUT}" ]]; then
  echo "category,us_per_op" > "${CSV_OUT}"
  echo "enc_crypto,${enc_us}" >> "${CSV_OUT}"
  echo "io_copy,${copy_us}" >> "${CSV_OUT}"
  echo "rb_net_read,${rb_read_us}" >> "${CSV_OUT}"
  echo "rb_net_write,${rb_write_us}" >> "${CSV_OUT}"
  echo "rb_net_wait,${rb_wait_us}" >> "${CSV_OUT}"
  echo "rb_other_sys,${rb_other_us}" >> "${CSV_OUT}"
  echo "rb_sys_total,${rb_sys_total_us}" >> "${CSV_OUT}"
  echo "[+] Wrote CSV: ${CSV_OUT}"
fi

